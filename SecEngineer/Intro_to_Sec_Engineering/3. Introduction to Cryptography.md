# Introduction to Cryptography

## Intro

What we'll see:

- Symmetric and asymmetric encryption
- Diffie-Hellman Key Exchange
- Hashing
- PKI

What would you need to send a secret message?: **A cipher!**

### Substitution Cipher

**Caesar Cipher:** This is one example of a **substitution cipher**. You can "rotate" the position of the letters of the message between 1 and 25 times (0 means no change and 26 would take you back to the first letter). The amount of rotations is the key.

![alt text](image.png)
*Source: https://commons.wikimedia.org/wiki/File:Symmetric_encryption.png*

**Mono-Alphabetic Substitution Cipher:**

We assign each letter of the alphabet another letter. The result is something like the image bellow. Bruteforcing a message ciphered this way would take a long time, but not long enough (like a week, so its not secure, anyway, you might want to google that).

![alt text](image-3.png)
*Figure: “Substitution cipher” by Meilani.conley, via Wikimedia Commons, licensed under CC BY-SA 4.0.  
Source: https://commons.wikimedia.org/wiki/File:Substitution_cipher.PNG
License: https://creativecommons.org/licenses/by-sa/4.0/  
Changes: none.*

### Transposition Cipher

We can encrypt the message my putting it into a matrix. We give a value to each column and them scramble them. The scrambled column order is the key and the text is ciphered.

![alt text](image-4.png)
*Source: https://commons.wikimedia.org/wiki/File:4-Letter_Transposition_cipher_Fig_XVI.png*

However, these are problems that can be solved in polynomial time. They are not hard enough and can be bruteforced.

"If the encrypted message can be broken in one week, the encryption used would be considered insecure. However, if the encrypted message can be broken in 1 million years, the encryption would be considered practically secure."

[quipqiup](https://www.quipqiup.com/) allows us to easily solve Mono-alphabetic substitution ciphers.

## Symmetric Encryption

### Encryption Terminology

- **Cryptographic Algorithm or Cipher**: Defines the encryption and decryption process
- **Key**: Used by the cryptographic algorithm to convert plaintext into ciphertext and vice versa
- **Plaintext**: Original message
- **Ciphertext**: Encrypted message

Symmetric encryption uses the same key for encryption and decryption.
So a sends something to b using the key to encrypt. b uses the same key to decrypt and see the message.

![Symmetric encryption diagram](image-2.png)

*Figure: “Symmetric encryption” by Munkhzaya Ganbold, via Wikimedia Commons, licensed under CC BY-SA 4.0.  
Source: https://commons.wikimedia.org/wiki/File:Symmetric_encryption.png  
License: https://creativecommons.org/licenses/by-sa/4.0/  
Changes: none.*


---

### AES

Advanced Encryption Standard uses a key size of 128, 192, or 256 bits. It is still considered secure, unlike DES (Data Encryption Standard). AES repeats the following four transformations multiple times:

1. SubBytes(state)
2. ShiftRows(state)
3. MixColumns(state)
4. AddRoundKey(state)

[This video](https://www.youtube.com/watch?v=C4ATDMIz5wc) does a great job demonstrating how AES works.

AES is a **block cipher algorithm**, which converts the input (plaintext) into blocks and encrypts each block.

The other type of symmetric encryption algorithm is **stream ciphers**, which encrypt the plaintext byte by byte.

---

✅ Symmetric encryption solves many sec. issues:

- Confidentiality: for obvious reasons...
- Integrity: Changes to the ciphertext would prevent decryption or would lead to a gibberish plaintext
- Authenticity: Only those who know the secret key can decrypt the message

❎  However:

Symmetric Encryption is not scalable: With two people we need 1 key. With 100 people we need 5000. The ratio is:

$$
K=\binom{n}{2}=\frac{n(n-1)}{2}
$$

- If a system gets compromised, all of their keys have to be recreated
- A secure chanel has to be found to exchange keys (in this case, many keys)

All of this is solved by **Asymmetric Encryption**.

### Symmetric Encryption in the Terminal

#### GNU Privacy Guard (GPG)

Check supported ciphers:

```bash
gpg --version
```

Encrypt (replace CIPHER with encryption algorithm):

```bash
gpg --symmetric --cipher-algo CIPHER message.txt
```

The result is saved as message.txt.gpg.

Decrypt:

```bash
gpg --output original_message.txt --decrypt message.gpg
```

#### OpenSSL Project

Encrypt:

```bash
openssl aes-256-cbc -e -in message.txt -out encrypted_message
```

Decrypt:

```bash
openssl aes-256-cbc -d -in encrypted_message -out original_message.txt
```

Encryption + Password-Based Key Derivation Function 2 (PBKDF2) and iterations on the password:

```bash
openssl aes-256-cbc -pbkdf2 -iter 10000 -e -in message.txt -out encrypted_message
```

Decryption:

```bash
openssl aes-256-cbc -pbkdf2 -iter 10000 -d -in encrypted_message -out original_message.txt
```

## Asymmetric Encryption

No need to find a secure channel through asymmetric encryption because we have two keys:

- One is public, you can share it with anyone.
- Another is private, only you should know it.

With your public key anyone can encrypt the message but only the private key holder can decrypt it.
Conversely, a private key can be used to encrypt something and any holder of the public key can decrypt it.

It is not mathematically feasible to get the private key through the public one!
So, we only need to make the channel reliable (to protect integrity, not confidentiality).

Aside from Confidentiality, Asymmetric Encryption aids:

- Integrity: If the message, encrypted through the private key, is successfully decrypted through the public key, the message was not altered across the way.
- Authenticity: Since no one else has access to the private key, the message must come from the private key owner.
- Nonrepudiation: For the same reason, they cannot deny sending this message.

### RSA

If you **really** want to know the math behind the RSA asymmetric encryption algorithm watch these two:

- [RSA: Computing an Example](https://youtu.be/4zahvcJ9glg?si=Kg_BA-OZtEGM0AB_)
- [RSA: Generating the keys](https://youtu.be/oOcTVTpUsPQ?si=zLjiRQd5CGzLOZVA)

The security of RSA relies on the difficulty of factoring large numbers $(N)$ into their two prime components ($p$ and $q$). While multiplication $(p×q=N)$ is easy, reversing it is extremely hard. For security, p and q must be very large (e.g., 1024 bits each, over 300 digits). The system also critically depends on using secure random numbers to generate $p$ and $q$; if an attacker can guess these primes, the security fails.

### Asymmetric Encryption in the Terminal

Generate the private key using openSSL:

```bash
openssl genrsa -out private-key.pem 2048
```

Get the public key component from the private:

```bash
openssl rsa -in private-key.pem -pubout -out public-key.pem
```

See the real RSA variables ($p$, $q$, $N$, $e$ and $d$):

```bash
openssl rsa -in private-key.pem -text -noout
```

Encrypt using the rsa public key:

```bash
openssl pkeyutl -encrypt -in plaintext.txt -out ciphertext -inkey public-key.pem -pubin
```

Decrypt using the private key:

```bash
openssl pkeyutl -decrypt -in ciphertext -inkey private-key.pem -out decrypted.txt
```

## Diffie-Hellman Key Exchange

Diffie-Hellman is an method for securely generating a symmetric key over a public channel.

[I recommend this video](https://www.youtube.com/watch?v=85oMrKd8afY&t=1s) for understanding how Diffie-Hellman works.

### Diffie-Hellman in the Terminal

Generate Diffie-Hellman parameters:

```bash
openssl dhparam -out dhparams.pem 2048
```

See the $P$ and $G$ parameters generated:

```bash
openssl dhparam -in dhparams.pem -text -noout
```

## Hashing

Algorithm that takes data of arbitrary size and returns a **fixed size value** (regardless of file size), called a *message digest* or *checksum*.

```sha256sum``` Returns a checksum of 256 bits (32 bytes or 64 hex characters).

Hashing is useful for:

- storing passwords: We can store hashes instead of passwords. It is not mathematically feasible to get a password from a hash.
- detecting modifications: Any (even a single bit) modification to the plaintext produces a completely different hash.

These hashes are still considered secured:

- SHA224, SHA256, SHA384
- RIPEMD160

These hashes are cryptographically broken:

- MD5, SHA-1

### HMAC

[This video](https://www.youtube.com/watch?v=fzMIjWFYQl0) does a good job explaining what is MAC and HMAC and why do we need them.
The main point is that *just hashing isn't enough*. That is where MAC (a message authentication code) comes handy. HMAC (Hash-based message authentication code) is MAC but defines a standard (or agreement) on how to use the message authentication code.

### HMAC in the Terminal

```bash
hmac256 s!Kr37 message.txt
```

```bash
sha256hmac message.txt --key s!Kr37
```

## PKI and SSL/TLS

Diffie-Hellman is still vulnerable to Man-In-the-Middle attacks. 

"The reason is that Alice has no way of ensuring that she is communicating with Bob, and Bob has no way of ensuring that he is communicating with Alice when exchanging the secret key.".

This susceptibility necessitates some mechanism that would allow us to confirm the other party’s identity. This brings us to Public Key Infrastructure (PKI) and Transport Layer Security (TLS).

### PKI

PKI refers to "tools used to create and manage public keys for encryption, which is a common method of securing data transfers on the internet. PKI is built into all web browsers used today".

PKI works through the implementation of two technologies:

1. Certificates:  Documents emitted by CA Certificate Authorities (CA) that grant an entity permission to engage in the exchange of PKI keys (includes the public key)
2. keys (public and private).

### SSL/TLS

TLS is a security protocol that allows application and servers to send data in an encrypted form. You can view TLS as a protocol that works on top of transport protocols (TCP and UDP) allowing things like HTTPS, SSH and NTP. 

SSL is older than TLS, but served the same purpose. It is now deprecated.

TLS is what *actually* uses the certificates within the TLS Handshake

![alt text](image-1.png)
*Source: https://commons.wikimedia.org/wiki/File:Full_TLS_1.2_Handshake.svg*

